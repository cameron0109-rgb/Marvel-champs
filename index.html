<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Marvel Champions — Spider-Man vs Rhino (Trial)</title>
<style>
  :root{
    --bg:#0f1720; --card:#ffffff; --muted:#a6b0bd; --accent:#ff5252;
    --panel:#0b1220; --tile:#0f1725;
  }
  html,body{height:100%; margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial; background:linear-gradient(180deg,#071020 0%, #0b1722 100%); color:#e6eef6;}
  .app{max-width:980px;margin:8px auto;padding:10px;}
  header{display:flex;align-items:center;justify-content:space-between;gap:10px}
  h1{font-size:1.15rem;margin:0}
  .muted{color:var(--muted);font-size:0.9rem}
  .controls, .board{display:flex;gap:12px; margin-top:12px; flex-wrap:wrap}
  .panel{background:linear-gradient(180deg,#0b1530, #08121f); border-radius:10px; padding:12px; box-shadow:0 6px 18px rgba(2,6,23,0.6); flex:1 1 300px; min-width:260px}
  label{display:block;margin:6px 0;color:var(--muted); font-size:0.9rem}
  select,input[type=checkbox]{margin-left:6px}
  .btn{background:linear-gradient(180deg,#21a0ff,#0077cc); color:white; border:none; padding:8px 10px;border-radius:8px;font-weight:600}
  .btn.secondary{background:linear-gradient(180deg,#f04,#b30d0d)}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.08); color:var(--muted); padding:6px 8px}
  .hero-area,.villain-area,.schemes-area{display:flex;flex-direction:column;gap:8px}
  .card-row{display:flex;flex-wrap:wrap;gap:8px}
  .card-tile{width:120px; background:var(--card); color:#08121f; border-radius:8px; padding:6px; box-shadow:0 4px 14px rgba(2,6,23,0.5); display:flex;flex-direction:column;align-items:center}
  .card-img{width:100%;height:160px;border-radius:6px;object-fit:cover;border:1px solid rgba(0,0,0,0.06)}
  .card-title{font-size:0.85rem;margin-top:6px;font-weight:700}
  .card-sub{font-size:0.78rem;color:#333}
  .card-actions{display:flex;gap:6px;margin-top:6px}
  .small{font-size:0.8rem;color:var(--muted)}
  .topbar{display:flex;gap:10px;align-items:center}
  #log{height:120px;overflow:auto;background:linear-gradient(180deg,#07121a,#04111b);border-radius:8px;padding:8px;color:#cfe7ff;font-size:0.85rem}
  .stat{background:rgba(255,255,255,0.03);padding:6px;border-radius:6px;font-weight:600}
  .flex{display:flex;gap:8px;align-items:center}
  /* mobile adjustments */
  @media (max-width:700px){
    .card-img{height:120px}
    .card-tile{width:140px}
    .panel{min-width:unset;flex-basis:100%}
  }
</style>
</head>
<body>
  <div class="app">
    <header>
      <div>
        <h1>Marvel Champions — Spider-Man vs Rhino</h1>
        <div class="muted">Full Game Test 3 — Playable PWA-style single file</div>
      </div>
      <div class="topbar">
        <div class="stat" id="turnDisplay">Turn: 1</div>
        <div class="stat" id="phaseDisplay">Phase: Setup</div>
      </div>
    </header>

    <!-- Setup panel -->
    <div class="controls">
      <div class="panel" id="setupPanel">
        <h2 style="margin:0 0 8px 0">Setup</h2>
        <label>Villain:
          <select id="villainSelect"><option value="rhino">Rhino</option></select>
        </label>
        <label>Difficulty:
          <select id="difficultySelect"><option value="1">Standard (1 & 2)</option><option value="2">Expert (2 & 3)</option></select>
        </label>
        <label>Modular side schemes:</label>
        <label><input type="checkbox" id="modBomb"> Bomb Scare</label>
        <label><input type="checkbox" id="modHydra"> Hydra Agents</label>
        <div style="margin-top:10px;display:flex;gap:8px">
          <button class="btn" id="startBtn">Start Game</button>
          <button class="btn ghost" id="resetBtn">Reset</button>
        </div>
        <div class="muted" style="margin-top:8px">Tip: tap a card's Play or Discard button. End turn to trigger villain phase.</div>
      </div>

      <!-- HUD -->
      <div class="panel">
        <h3 style="margin:0 0 8px 0">Hero</h3>
        <div id="heroHUD" style="display:grid;grid-template-columns:1fr 1fr;gap:8px">
          <div>
            <div class="small">Name</div>
            <div id="heroName" style="font-weight:700">Spider-Man</div>
            <div class="small">Form</div>
            <div id="heroForm" style="font-weight:700">Alter-Ego</div>
          </div>
          <div>
            <div class="small">HP</div>
            <div id="heroHP" style="font-weight:700">—</div>
            <div style="margin-top:6px" class="small">Resources</div>
            <div id="heroRes" style="font-weight:700">0</div>
          </div>
        </div>

        <div style="margin-top:8px;display:flex;gap:6px;flex-wrap:wrap">
          <button class="btn" id="toggleFormBtn">Toggle Form</button>
          <button class="btn ghost" id="readyBtn">Ready</button>
          <button class="btn secondary" id="endTurnBtn">End Turn</button>
        </div>

        <div style="margin-top:10px">
          <div class="small">Hand (<span id="handSize">0</span>) | Deck: <span id="deckSize">0</span> | Discard: <span id="discardSize">0</span></div>
        </div>
      </div>

      <div class="panel">
        <h3 style="margin:0 0 8px 0">Villain</h3>
        <div><strong id="villainName">Rhino</strong></div>
        <div class="flex" style="margin-top:6px">
          <div><div class="small">HP</div><div id="villainHP" style="font-weight:700">30</div></div>
          <div><div class="small">Stage</div><div id="villainStage" style="font-weight:700">1</div></div>
          <div><div class="small">Deck</div><div id="villainDeckCount" style="font-weight:700">0</div></div>
        </div>
        <div style="margin-top:8px" class="small">Active Card</div>
        <div id="activeVillainCard" style="min-height:34px;margin-top:6px"></div>
      </div>
    </div>

    <!-- Game board -->
    <div class="board" style="margin-top:12px">
      <div class="panel" style="flex:2">
        <h3 style="margin:0 0 8px 0">Hero Hand</h3>
        <div id="handRow" class="card-row"></div>
      </div>

      <div class="panel" style="flex:1;min-width:260px">
        <h3 style="margin:0 0 8px 0">Schemes</h3>
        <div id="mainScheme" style="margin-bottom:8px"></div>
        <div id="sideSchemes"></div>
        <h3 style="margin-top:12px;margin-bottom:6px">Game Log</h3>
        <div id="log"></div>
      </div>
    </div>

    <footer style="margin-top:12px;font-size:0.8rem;color:var(--muted)">Built for testing. Add more heroes/villains later. All art is generated, non-trademarked.</footer>
  </div>

<script>
/* --------------------
   Utility & SVG art generator
   -------------------- */
function htmlEscape(s){ return String(s).replace(/[&<>"']/g,c=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c])); }

function svgCardDataURI(title, typeColor, subtitle){
  // create a simple cartoony SVG for card
  const w=400,h=560;
  const svg = `
  <svg xmlns='http://www.w3.org/2000/svg' width='${w}' height='${h}' viewBox='0 0 ${w} ${h}'>
    <defs>
      <linearGradient id='g' x1='0' x2='0' y1='0' y2='1'>
        <stop offset='0' stop-color='${typeColor}' stop-opacity='1'/>
        <stop offset='1' stop-color='#ffffff' stop-opacity='0.05'/>
      </linearGradient>
      <filter id='f' x='-20%' y='-20%' width='140%' height='140%'>
        <feDropShadow dx='0' dy='6' stdDeviation='10' flood-color='#000' flood-opacity='0.35'/>
      </filter>
    </defs>
    <rect rx='18' ry='18' width='100%' height='100%' fill='url(#g)' stroke='#031018' stroke-width='6' filter='url(#f)'/>
    <g transform='translate(20,28)'>
      <rect width='360' height='240' rx='12' fill='rgba(255,255,255,0.12)'/>
      <text x='180' y='130' text-anchor='middle' font-size='86' fill='white' font-family='sans-serif'>${title.slice(0,18)}</text>
    </g>

    <g transform='translate(26,300)'>
      <text x='0' y='0' font-family='sans-serif' font-size='28' fill='#091623' font-weight='700'>${htmlEscape(title)}</text>
      <text x='0' y='34' font-family='sans-serif' font-size='18' fill='#0b2b3a'>${htmlEscape(subtitle||"")}</text>
    </g>
  </svg>
  `;
  return "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg);
}

/* --------------------
   Game state
   -------------------- */
let state = {
  turn:1,
  phase:"setup",
  hero:{},
  villain:{},
  mainScheme:{},
  sideSchemes:[],
  log:[],
};

/* ---------- START: card library (text-only cards) ---------- */
/* For brevity I used 40 Spider-Man-like cards (names, cost, atk/thw/def, text).
   If you want exact core-box text later we can replace each card's text precisely. */

const SPIDER_40 = [
  {name:"Web-Shooters", cost:2, type:"upgrade", attack:2, thwart:0, defend:0, text:"Equip: Attack 2."},
  {name:"Spider-Sense", cost:0, type:"response", attack:0, thwart:0, defend:0, trigger:"afterAttack", text:"Response — after an enemy attacks you, ready your hero."},
  {name:"Quick Reflexes", cost:1, type:"event", attack:0, thwart:0, defend:0, text:"Ready your hero."},
  {name:"Black Cat (Ally)", cost:3, type:"ally", attack:2, thwart:0, defend:0, text:"Ally — Attack 2."},
  {name:"Web Grenade", cost:2, type:"event", attack:1, thwart:1, defend:0, text:"Attack 1 and Thwart 1."},
  {name:"Acrobatic Maneuvers", cost:1, type:"event", attack:0, thwart:1, defend:1, text:"Thwart 1 and gain 1 defend."},
  {name:"Spider-Bots", cost:3, type:"upgrade", attack:1, thwart:1, defend:0, text:"Upgrade — Attack 1 & Thwart 1."},
  {name:"MJ (Ally)", cost:3, type:"ally", attack:0, thwart:2, defend:0, text:"Ally — Thwart 2."},
  {name:"Adrenaline Rush", cost:1, type:"event", attack:1, thwart:0, defend:0, text:"Attack 1 and ready hero."},
  {name:"Web Sling", cost:2, type:"event", attack:2, thwart:0, defend:0, text:"Attack 2."},
  {name:"Spider Climb", cost:1, type:"event", attack:0, thwart:0, defend:1, text:"Provide 1 defend."},
  {name:"Web Net", cost:2, type:"event", attack:0, thwart:2, defend:0, text:"Thwart 2."},
  {name:"Swing into Action", cost:1, type:"event", attack:1, thwart:0, defend:0, text:"Attack 1."},
  {name:"Rapid Reflexes", cost:1, type:"event", attack:0, thwart:1, defend:1, text:"Thwart 1, Defend 1."},
  {name:"Quick Strike", cost:1, type:"event", attack:1, thwart:0, defend:0, text:"Attack 1."},
  {name:"Rescue Civilians", cost:1, type:"event", attack:0, thwart:1, defend:0, text:"Thwart 1."},
  {name:"Acrobatics", cost:1, type:"event", attack:0, thwart:1, defend:1, text:"Thwart 1, Defend 1."},
  {name:"Spider Kick", cost:1, type:"event", attack:1, thwart:0, defend:0, text:"Attack 1."},
  {name:"Wall Crawl", cost:1, type:"event", attack:0, thwart:0, defend:1, text:"Defend 1."},
  {name:"Web Trap", cost:2, type:"event", attack:0, thwart:2, defend:0, text:"Thwart 2."},
  {name:"Spider Swing", cost:1, type:"event", attack:1, thwart:0, defend:0, text:"Attack 1."},
  {name:"Agility Training", cost:1, type:"event", attack:0, thwart:1, defend:1, text:"Thwart 1, Defend 1."},
  {name:"Spider Companion", cost:2, type:"ally", attack:1, thwart:1, defend:0, text:"Ally — Attack 1 & Thwart 1."},
  {name:"Quick Dodge", cost:1, type:"event", attack:0, thwart:0, defend:1, text:"Defend 1."},
  {name:"Web Shield", cost:2, type:"event", attack:0, thwart:0, defend:2, text:"Defend 2."},
  {name:"Patrol", cost:1, type:"event", attack:0, thwart:1, defend:0, text:"Thwart 1."},
  {name:"Rescue Mission", cost:1, type:"event", attack:0, thwart:1, defend:0, text:"Thwart 1."},
  {name:"Web Swing Attack", cost:2, type:"event", attack:2, thwart:0, defend:0, text:"Attack 2."},
  {name:"Heroic Strike", cost:1, type:"event", attack:1, thwart:0, defend:0, text:"Attack 1."},
  {name:"Alert!", cost:1, type:"event", attack:0, thwart:1, defend:0, text:"Thwart 1."},
  {name:"Spider Allies", cost:2, type:"event", attack:1, thwart:1, defend:0, text:"Attack 1 & Thwart 1."},
  {name:"Rapid Webbing", cost:2, type:"event", attack:1, thwart:1, defend:0, text:"Attack 1 & Thwart 1."},
  {name:"Web Barrage", cost:2, type:"event", attack:2, thwart:0, defend:0, text:"Attack 2."},
  {name:"Clever Tactics", cost:1, type:"event", attack:0, thwart:1, defend:1, text:"Thwart 1, Defend 1."},
  {name:"Evasive Maneuver", cost:1, type:"event", attack:0, thwart:1, defend:1, text:"Thwart 1, Defend 1."},
  {name:"Spider Alert", cost:1, type:"event", attack:0, thwart:1, defend:0, text:"Thwart 1."},
  {name:"Acrobatic Attack", cost:1, type:"event", attack:1, thwart:0, defend:1, text:"Attack 1 & Defend 1."},
  {name:"Web Strike", cost:2, type:"event", attack:2, thwart:0, defend:0, text:"Attack 2."},
  {name:"Heroic Assistance", cost:2, type:"ally", attack:1, thwart:1, defend:0, text:"Ally — Attack 1 & Thwart 1."},
  {name:"Spider Initiative", cost:1, type:"event", attack:0, thwart:1, defend:0, text:"Thwart 1."}
];

/* Rhino standard encounter deck array (shortened to realistic set for trial) */
const RHINO_STANDARD = [
  {name:"Rhino Charge", type:"attack", attack:3, modifier:1, text:"Rhino charges!"},
  {name:"Trample", type:"attack", attack:4, modifier:0, text:"Rhino tramples the area."},
  {name:"Stomp", type:"attack", attack:2, modifier:1, text:"Rhino stomps."},
  {name:"Rampage", type:"attack", attack:3, modifier:2, text:"Rhino rampages."},
  {name:"Main Scheme Threat", type:"threat", threat:2, modifier:0, text:"Threat added to main scheme."},
  {name:"Minion Reinforcements", type:"minion", attack:1, thwart:0, modifier:0, text:"Minion arrives."},
  {name:"Side Scheme Threat", type:"threat", threat:1, modifier:0, text:"Threat to a side scheme."},
  {name:"Head Butt", type:"attack", attack:3, modifier:1, text:"Rhino head butt."},
  {name:"Charge Forward", type:"attack", attack:2, modifier:0, text:"Rhino charges forward."},
  {name:"Rampage Run", type:"attack", attack:2, modifier:2, text:"Rhino runs rampage."},
  {name:"Minion Backup", type:"minion", attack:1, thwart:0, modifier:0, text:"Minion backup."},
  {name:"Smash Obstacle", type:"attack", attack:1, modifier:1, text:"Smash obstacle causing chaos."},
  // duplicate entries to make deck size reasonable
  {name:"Rhino Charge (2)", type:"attack", attack:3, modifier:1, text:"Rhino charges!"},
  {name:"Trample (2)", type:"attack", attack:4, modifier:0, text:"Rhino tramples again."},
  {name:"Stomp (2)", type:"attack", attack:2, modifier:1, text:"Stomp again."},
  {name:"Minion Reinforcements (2)", type:"minion", attack:1, thwart:0, modifier:0, text:"More minions!"},
  {name:"Main Scheme Threat (2)", type:"threat", threat:2, modifier:0, text:"More threat."},
  {name:"Charge Forward (2)", type:"attack", attack:2, modifier:0, text:"Charge again."},
  {name:"Head Butt (2)", type:"attack", attack:3, modifier:1, text:"Head butt repeat."},
  {name:"Rampage Run (2)", type:"attack", attack:2, modifier:2, text:"Another rampage."}
];

const RHINO_MODULAR = {
  bomb: {name:"Bomb Scare", type:"scheme", threat:1, text:"Bomb Scare modular: adds threat to Bomb Scare side scheme."},
  hydra: {name:"Hydra Agents", type:"minion", attack:1, thwart:1, text:"Hydra agents appear."}
};

/* ---------- END card library ---------- */

/* -------------------
   Game initialization
   ------------------- */
function resetState(){
  state.turn = 1;
  state.phase = "setup";
  state.log = [];
  state.hero = {
    name:"Spider-Man",
    form:"alter", // "alter" or "hero"
    exhausted:false,
    resources:0,
    hp:10, maxHp:10,
    defend:0,
    hand:[], deck:[], discard:[]
  };
  // build hero deck (copy)
  state.hero.deck = SPIDER_40.slice();
  shuffle(state.hero.deck);
  // villain
  state.villain = { name:"Rhino", hp:30, stage:1, deck:[], discard:[], minions:[]};
  state.mainScheme = {name:"Main Scheme", threat:0, max:10};
  state.sideSchemes = [];
  saveToStorage();
  renderAll();
}

function saveToStorage(){ try{ localStorage.setItem("mc_state", JSON.stringify(state)); }catch(e){} }
function loadFromStorage(){ try{ const s=localStorage.getItem("mc_state"); if(s) state = JSON.parse(s); }catch(e){} }

/* -------------------
   UI helpers
   ------------------- */
function log(msg){
  const t = new Date().toLocaleTimeString();
  state.log.unshift(`[${t}] ${msg}`);
  if(state.log.length>200) state.log.length=200;
  const el = document.getElementById("log");
  el.innerHTML = state.log.map(l=>`<div>${htmlEscape(l)}</div>`).join("");
  saveToStorage();
}

function setPhase(p){ state.phase=p; document.getElementById("phaseDisplay").innerText = `Phase: ${p}`; }

/* -------------------
   Render functions
   ------------------- */
function renderAll(){
  document.getElementById("turnDisplay").innerText = `Turn: ${state.turn}`;
  document.getElementById("heroName").innerText = state.hero.name;
  document.getElementById("heroForm").innerText = (state.hero.form==="hero"?"Hero":"Alter-Ego");
  document.getElementById("heroHP").innerText = (state.hero.form==="hero"? `${state.hero.hp}/${state.hero.maxHp}` : "—");
  document.getElementById("heroRes").innerText = state.hero.resources;
  document.getElementById("handSize").innerText = state.hero.hand.length;
  document.getElementById("deckSize").innerText = state.hero.deck.length;
  document.getElementById("discardSize").innerText = state.hero.discard.length;
  document.getElementById("villainName").innerText = state.villain.name;
  document.getElementById("villainHP").innerText = `${state.villain.hp}`;
  document.getElementById("villainStage").innerText = state.villain.stage;
  document.getElementById("villainDeckCount").innerText = state.villain.deck.length;

  // hero hand render
  const row = document.getElementById("handRow");
  row.innerHTML = "";
  state.hero.hand.forEach((c, idx)=>{
    const color = c.type==="event" ? "#4facfe" : (c.type==="upgrade"?"#48d49b":(c.type==="ally"?"#ffd166":"#8ecae6"));
    const img = svgCardDataURI(c.name, color, c.type.toUpperCase());
    const tile = document.createElement("div");
    tile.className = "card-tile";
    tile.innerHTML = `<img class="card-img" src="${img}" alt="${htmlEscape(c.name)}"><div class="card-title">${htmlEscape(c.name)}</div>
      <div class="small">${htmlEscape(c.text)}</div>
      <div class="card-actions">
        <button class="btn ghost" onclick="playCard(${idx})">Play</button>
        <button class="btn" onclick="discardCard(${idx})">Discard +1</button>
      </div>`;
    row.appendChild(tile);
  });

  // schemes and villain active card
  document.getElementById("mainScheme").innerHTML = `<div><strong>${state.mainScheme.name}</strong></div>
    <div class="small">Threat: ${state.mainScheme.threat} / ${state.mainScheme.max}</div>`;
  const sideEl = document.getElementById("sideSchemes");
  sideEl.innerHTML = "";
  state.sideSchemes.forEach((s,i)=> sideEl.innerHTML += `<div class="small"><strong>${s.name}</strong> — ${s.threat}/${s.max}</div>`);

  // active villain card area (last discarded)
  const last = state.villain.lastActive;
  document.getElementById("activeVillainCard").innerHTML = last ? `<div class="small"><strong>${htmlEscape(last.name)}</strong> — ${htmlEscape(last.text)}</div>` : `<div class="small">None</div>`;

  // update phase
  saveToStorage();
}

/* -------------------
   Card actions: Play & Discard per card
   ------------------- */
function playCard(index){
  const card = state.hero.hand[index];
  if(!card) return alert("Card not found.");
  if(card.cost > state.hero.resources){
    return alert("Not enough resources. Discard cards to gain resources.");
  }
  // pay cost
  state.hero.resources -= card.cost;
  // apply effects: attack /thwart / defend
  if(card.attack && card.attack>0){
    const dmg = card.attack;
    if(state.hero.form === "hero"){
      state.villain.hp = Math.max(0, state.villain.hp - dmg);
      log(`${state.hero.name} plays ${card.name} and attacks Rhino for ${dmg}. Rhino HP ${state.villain.hp}.`);
    } else {
      // alter-ego: convert to threat on main scheme
      state.mainScheme.threat += dmg;
      log(`${card.name} added ${dmg} threat to Main Scheme (Alter-Ego).`);
      checkSchemeAdvance(state.mainScheme);
    }
  }
  if(card.thwart && card.thwart>0){
    const th = card.thwart;
    state.mainScheme.threat = Math.max(0, state.mainScheme.threat - th);
    log(`${state.hero.name} plays ${card.name} and thwarts ${th}. Main threat ${state.mainScheme.threat}.`);
  }
  if(card.defend && card.defend>0){
    state.hero.defend = (state.hero.defend || 0) + card.defend;
    log(`${state.hero.name} gains ${card.defend} defense (stacked for next attacks).`);
  }
  // If card has ready effect etc (simple handling)
  if(card.trigger === "ready") {
    state.hero.exhausted = false;
    log(`${card.name} readies hero.`);
  }
  // remove from hand -> discard
  state.hero.discard.push(card);
  state.hero.hand.splice(index,1);
  state.hero.exhausted = true; // basic action consumes action (attack/thwart/defend)
  renderAll();
  checkVictory();
}

function discardCard(index){
  const card = state.hero.hand[index];
  state.hero.discard.push(card);
  state.hero.hand.splice(index,1);
  state.hero.resources += 1;
  log(`Discarded ${card.name} for 1 resource. Resources: ${state.hero.resources}`);
  renderAll();
}

/* -------------------
   Hero draw & reshuffle
   ------------------- */
function drawCard(){
  if(state.hero.deck.length === 0){
    if(state.hero.discard.length === 0) return alert("No cards to draw!");
    state.hero.deck = state.hero.discard.slice();
    state.hero.discard = [];
    shuffle(state.hero.deck);
    log("Hero deck reshuffled.");
  }
  const c = state.hero.deck.pop();
  state.hero.hand.push(c);
  renderAll();
}
function drawHeroCard(){ drawCard(); }

/* -------------------
   Hero abilities / exhaust / ready
   ------------------- */
function useHeroAbility(action){
  if(state.hero.exhausted) return alert("Hero exhausted (used action). Ready to use again.");
  // for simplicity: basic abilities map to forms/stats
  if(action === "attack"){
    // use hero base attack (1 by default) if no card chosen - small
    let base = 1;
    if(state.hero.form === "hero"){
      // perform attack
      state.villain.hp = Math.max(0, state.villain.hp - base);
      log(`${state.hero.name} uses base attack for ${base}. Rhino HP ${state.villain.hp}.`);
    } else {
      state.mainScheme.threat += base;
      log(`${state.hero.name} (Alter) converts attack to ${base} threat.`);
      checkSchemeAdvance(state.mainScheme);
    }
  }
  if(action === "thwart"){
    const base = 1;
    state.mainScheme.threat = Math.max(0, state.mainScheme.threat - base);
    log(`${state.hero.name} uses base thwart ${base}. Main threat ${state.mainScheme.threat}`);
  }
  if(action === "defend"){
    state.hero.defend = (state.hero.defend||0) + 1;
    log(`${state.hero.name} defends 1 (for upcoming attack).`);
  }
  if(action === "ability"){
    // use form ability: rough mapping
    if(state.hero.form === "hero"){
      log(`${state.hero.name} uses Hero ability: ${state.hero.name} swings into action!`);
      // small effect: deal 1
      state.villain.hp = Math.max(0, state.villain.hp - 1);
    } else {
      log(`${state.hero.name} uses Alter-Ego ability: recovers focus (draw 1).`);
      drawCard();
    }
  }
  state.hero.exhausted = true;
  renderAll();
  checkVictory();
}

function readyHero(){
  state.hero.exhausted = false;
  state.hero.defend = 0;
  log("Hero readied.");
  renderAll();
}

/* -------------------
   Toggle hero form
   ------------------- */
function toggleForm(){
  state.hero.form = (state.hero.form === "hero") ? "alter" : "hero";
  state.hero.exhausted = false;
  if(state.hero.form === "hero"){
    state.hero.hp = state.hero.maxHp;
    log("Switched to HERO form.");
  } else {
    log("Switched to ALTER-EGO form.");
  }
  renderAll();
}

/* -------------------
   Villain deck build & modular
   ------------------- */
function buildVillainDeck(){
  state.villain.deck = RHINO_STANDARD.slice();
  // always include standard. if modular selected, push those specific cards (multiple copies if desired)
  if(document.getElementById("modBomb").checked){
    state.sideSchemes.push({name:"Bomb Scare", threat:0, max:5, advanceEffect: function(){ log("Bomb Scare advances: BOOM!"); }});
    state.villain.deck.push(RHINO_MODULAR.bomb);
  }
  if(document.getElementById("modHydra").checked){
    state.sideSchemes.push({name:"Hydra Agents", threat:0, max:4, advanceEffect: function(){ log("Hydra Agents advance: spawn minion."); }});
    state.villain.deck.push(RHINO_MODULAR.hydra);
  }
  shuffle(state.villain.deck);
}

/* -------------------
   Villain phase: reveal + draw
   ------------------- */
function endHeroTurn(){
  if(state.phase === "villain") return;
  setPhase("villain");
  log("Hero ends turn. Villain phase begins.");
  villainPhase().then(()=>{ // after villain resolves
    // After villain turn ends:
    state.turn += 1;
    state.hero.exhausted = false; // default ready at start of new round (or you can change)
    setPhase("hero");
    renderAll();
    saveToStorage();
  });
}

async function villainPhase(){
  // ensure at least two cards
  if(state.villain.deck.length < 2){
    reshuffleVillain();
  }
  // Reveal card (modifier)
  const reveal = state.villain.deck.pop();
  state.villain.discard.push(reveal);
  state.villain.lastActive = reveal;
  log(`Villain reveals: ${reveal.name} (modifier ${reveal.modifier||0})`);
  // Apply modifier immediately — for attack/thwart, it modifies next action's values or immediate threat application
  // We'll apply modifier in the next drawn action; we store it to use as +modifier.
  const modifier = reveal.modifier || 0;

  // Draw second card to perform action
  if(state.villain.deck.length === 0) reshuffleVillain();
  const actionCard = state.villain.deck.pop();
  state.villain.discard.push(actionCard);
  state.villain.lastActive = actionCard;
  log(`Villain action card drawn: ${actionCard.name} — ${actionCard.text || ""}`);

  // Resolve with modifier applied
  await resolveVillainCard(actionCard, modifier);

  // After resolution update UI
  renderAll();
}

function reshuffleVillain(){
  if(state.villain.discard.length === 0) return;
  state.villain.deck = state.villain.discard.slice();
  state.villain.discard = [];
  shuffle(state.villain.deck);
  log("Villain deck reshuffled.");
}

/* resolve villain card with modifier applied */
async function resolveVillainCard(card, modifier){
  const mod = modifier || 0;
  switch(card.type){
    case "attack":{
      const dmg = (card.attack||0) + mod - (state.hero.defend||0);
      if(state.hero.form === "hero"){
        const applied = Math.max(0,dmg);
        state.hero.hp = Math.max(0, state.hero.hp - applied);
        log(`Villain ${card.name} attacks for ${card.attack||0} (+${mod}) minus defend ${state.hero.defend||0} => ${applied} damage. Hero HP ${state.hero.hp}.`);
      } else {
        // alter ego: add threat to main scheme
        state.mainScheme.threat += (card.attack||0) + mod;
        log(`Villain ${card.name} (Alter-Ego) adds ${(card.attack||0)+mod} threat to Main Scheme -> ${state.mainScheme.threat}/${state.mainScheme.max}`);
        checkSchemeAdvance(state.mainScheme);
      }
      break;
    }
    case "threat":{
      const t = (card.threat||0) + mod;
      // choose side scheme if exists, otherwise main scheme
      if(state.sideSchemes.length>0){
        // simplest: add to first side scheme
        state.sideSchemes[0].threat += t;
        log(`Villain adds ${t} threat to side scheme ${state.sideSchemes[0].name} -> ${state.sideSchemes[0].threat}/${state.sideSchemes[0].max}`);
        checkSideAdvance(0);
      } else {
        state.mainScheme.threat += t;
        log(`Villain adds ${t} threat to Main Scheme -> ${state.mainScheme.threat}/${state.mainScheme.max}`);
        checkSchemeAdvance(state.mainScheme);
      }
      break;
    }
    case "minion":{
      // spawn simple minion object
      const m = {name: card.name, hp:2+(card.attack||0), attack: card.attack||1};
      state.villain.minions.push(m);
      log(`Minion spawned: ${m.name} (HP ${m.hp}, ATK ${m.attack})`);
      break;
    }
    case "scheme":{
      const t = (card.threat||0) + mod;
      // add to appropriate side scheme if matches name, else main
      if(card.name && card.name.toLowerCase().includes("bomb") && state.sideSchemes.find(s=>s.name==="Bomb Scare")){
        const idx = state.sideSchemes.findIndex(s=>s.name==="Bomb Scare");
        state.sideSchemes[idx].threat += t;
        log(`Bomb Scare gets ${t} threat -> ${state.sideSchemes[idx].threat}/${state.sideSchemes[idx].max}`);
        checkSideAdvance(idx);
      } else {
        state.mainScheme.threat += t;
        log(`Scheme event adds ${t} threat to Main -> ${state.mainScheme.threat}/${state.mainScheme.max}`);
        checkSchemeAdvance(state.mainScheme);
      }
      break;
    }
    default:
      log(`Villain card type ${card.type} not handled specifically.`);
  }

  // small delay to make flow readable
  await new Promise(r=>setTimeout(r, 350));
  // clear hero defend after attack
  state.hero.defend = 0;
  saveToStorage();
  renderAll();
  checkVictory();
}

/* -------------------
   Scheme advance checks
   ------------------- */
function checkSchemeAdvance(scheme){
  if(scheme.threat >= scheme.max){
    log(`Scheme ${scheme.name} advances!`);
    scheme.threat = 0;
    // main scheme advance increases villain stage
    state.villain.stage += 1;
    log(`Villain advances to stage ${state.villain.stage}.`);
    // optionally increase villain hp or other effects; simple mapping:
    state.villain.hp += 5; // escalate a bit
    renderAll();
  }
}

function checkSideAdvance(index){
  const s = state.sideSchemes[index];
  if(s.threat >= s.max){
    log(`Side scheme ${s.name} advances!`);
    s.threat = 0;
    if(s.advanceEffect) s.advanceEffect();
  }
}

/* -------------------
   Win/Lose
   ------------------- */
function checkVictory(){
  if(state.villain.hp <= 0){
    alert("Villain defeated — You win!");
    log("Game ended: Hero victory.");
  }
  if(state.hero.form === "hero" && state.hero.hp <= 0){
    alert("Hero knocked out — You lose.");
    log("Game ended: Hero defeated.");
  }
}

/* -------------------
   Setup & start
   ------------------- */
document.getElementById("startBtn").addEventListener("click", ()=>{
  // build initial state
  state.turn = 1;
  state.phase = "hero";
  // hero deck already present in state from resetState; but if re-start, reset hero deck:
  state.hero.deck = SPIDER_40.slice();
  shuffle(state.hero.deck);
  state.hero.hand = [];
  state.hero.discard = [];
  state.hero.resources = 2; // starting resources
  state.hero.exhausted = false;
  state.hero.form = "alter";
  state.hero.hp = state.hero.maxHp = 10;
  // villain deck
  state.villain.deck = RHINO_STANDARD.slice();
  state.villain.discard = [];
  state.villain.minions = [];
  state.villain.hp = 30;
  state.villain.stage = 1;
  state.mainScheme = {name:"Main Scheme", threat:0, max:10};
  state.sideSchemes = [];
  // modular additions
  if(document.getElementById("modBomb").checked){
    state.sideSchemes.push({name:"Bomb Scare", threat:0, max:5, advanceEffect:function(){ log("BOOM: Bomb Scare side scheme advanced!"); }});
    state.villain.deck.push(RHINO_MODULAR.bomb);
  }
  if(document.getElementById("modHydra").checked){
    state.sideSchemes.push({name:"Hydra Agents", threat:0, max:4, advanceEffect:function(){ log("Hydra side scheme advanced: Hydra swarms!"); }});
    state.villain.deck.push(RHINO_MODULAR.hydra);
  }
  shuffle(state.villain.deck);
  // draw initial hand
  for(let i=0;i<6;i++){ drawCard(); }
  document.getElementById("setupPanel").style.display = "none";
  setPhase("hero");
  log("Game started. Good luck!");
  renderAll();
  saveToStorage();
});

document.getElementById("resetBtn").addEventListener("click", ()=>{
  if(confirm("Reset game and clear saved state?")){
    resetState();
    location.reload();
  }
});

/* -------------------
   Persist: load existing game if any
   ------------------- */
loadFromStorage();
if(!state.hero || !state.hero.deck) resetState();
renderAll();

/* Keyboard shortcuts for convenience (desktop)
   D = draw, E = end turn, R = ready, T = toggle form */
document.addEventListener("keydown", (e)=>{
  if(e.key === "d") drawCard();
  if(e.key === "e") endHeroTurn();
  if(e.key === "r") readyHero();
  if(e.key === "t") toggleForm();
});
</script>
</body>
</html>
